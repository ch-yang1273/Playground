# 타우리 JS ↔ Rust 통신 원리

타우리의 핵심 원리는 JavaScript 프론트엔드와 Rust 백엔드 간의 안전한 통신입니다.

## 기본 구조

```
JavaScript (Frontend) 
    ↓ invoke() 
Tauri Bridge (IPC)
    ↓ 
Rust Backend
```

## 통신 흐름 단계별

### 1. JavaScript → Rust 호출

**main.js에서 Rust 함수 호출:**
```javascript
// main.js:8
greetMsgEl.textContent = await invoke("greet", { name: greetInputEl.value });
```

- **invoke() 함수**: `window.__TAURI__.core.invoke()`를 통해 호출
- **명령어 이름**: `"greet"` - Rust 함수와 매칭
- **파라미터**: `{ name: greetInputEl.value }` - JSON으로 직렬화되어 전송

### 2. Rust에서 처리

**lib.rs에서 명령어 처리:**
```rust
// lib.rs:2-5
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}
```

- **`#[tauri::command]`**: 매크로가 이 함수를 타우리 명령어로 등록
- **함수 실행**: JavaScript에서 받은 `name` 파라미터로 처리
- **결과 반환**: `String`을 JavaScript로 다시 전송

### 3. 등록 과정

**lib.rs에서 명령어 핸들러 등록:**
```rust
// lib.rs:11
.invoke_handler(tauri::generate_handler![greet])
```

`tauri::generate_handler!` 매크로가 `greet` 함수를 명령어 핸들러로 등록

## 내부 동작 원리

### IPC (Inter-Process Communication)
- 타우리는 **webview (프론트엔드)**와 **Rust 프로세스 (백엔드)**가 분리되어 실행
- 둘 사이의 통신은 **IPC 채널**을 통해 이루어짐
- JSON 메시지로 데이터 교환

### 실제 통신 과정
```
1. JS: invoke("greet", {name: "홍길동"})
2. 타우리 브리지: JSON 직렬화 → {"cmd": "greet", "name": "홍길동"}
3. Rust: 명령어 매칭 → greet 함수 실행
4. Rust: 결과 반환 → "Hello, 홍길동! You've been greeted from Rust!"
5. 타우리 브리지: JSON 직렬화 → JavaScript Promise resolve
6. JS: greetMsgEl.textContent에 결과 표시
```

## 보안과 권한

### Capability 시스템
**capabilities/default.json:**
```json
{
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default"
  ]
}
```

- **Capability 시스템**: JavaScript에서 호출할 수 있는 명령어들을 제한
- **명시적 등록**: `#[tauri::command]`로 표시된 함수만 호출 가능
- **타입 안전성**: Rust의 타입 시스템으로 데이터 검증

## 왜 이런 구조인가?

### 장점
- **보안**: 웹 코드가 시스템에 직접 접근할 수 없음
- **성능**: 무거운 작업은 Rust에서 처리
- **안정성**: Rust의 메모리 안전성 + 웹의 유연성
- **크로스 플랫폼**: 하나의 코드로 모든 OS 지원

### vs Electron 비교
- **Electron**: Node.js 런타임 + 브라우저 엔진 (무거움)
- **Tauri**: Rust 바이너리 + 시스템 webview (가벼움)

## 예시 코드 분석

### 현재 프로젝트의 통신 흐름

1. **사용자가 입력하고 버튼 클릭**
2. **JavaScript에서 invoke() 호출**
   ```javascript
   await invoke("greet", { name: greetInputEl.value })
   ```
3. **Rust에서 greet 함수 실행**
   ```rust
   #[tauri::command]
   fn greet(name: &str) -> String {
       format!("Hello, {}! You've been greeted from Rust!", name)
   }
   ```
4. **결과를 JavaScript로 반환하여 화면에 표시**

이렇게 JavaScript와 Rust가 IPC를 통해 안전하고 효율적으로 통신하는 것이 타우리의 핵심 원리입니다!